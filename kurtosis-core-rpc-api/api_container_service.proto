syntax = "proto3";
package api_container_api;
// NOTE: It sucks that we have this Go-specific logic inside this file (which should be language-agnostic). However, the Protobuf team have
// taken a hard stance on this being the way it should be done, so we have to do it this way.
option go_package = "github.com/kurtosis-tech/kurtosis-client/golang/kurtosis_core_rpc_api_bindings";

import "google/protobuf/empty.proto";

service ApiContainerService {
  // Starts a lambda container into the network
  rpc LoadLambda(LoadLambdaArgs) returns (google.protobuf.Empty) {};

  // Executes a Kurtosis Lambda function on behalf of the user 
  rpc ExecuteLambda(ExecuteLambdaArgs) returns (ExecuteLambdaResponse) {};

  // Gets information about a loaded Lambda module
  rpc GetLambdaInfo(GetLambdaInfoArgs) returns (GetLambdaInfoResponse) {};

  // Tells the API container that the client has static files it would like the API container to know about
  // The API container will respond with paths inside the enclave directory; the client is then responsible for copying their
  //  files there
  rpc RegisterStaticFiles(RegisterStaticFilesArgs) returns (RegisterStaticFilesResponse) {};

  // Tells the API container that the client has files artifacts from the web that it would like the API container to know about
  // The API container will download these artifacts locally, so they're available when launching services
  rpc RegisterFilesArtifacts(RegisterFilesArtifactsArgs) returns (google.protobuf.Empty) {};

  // Registers a service with the API container but doesn't start the container for it
  rpc RegisterService(RegisterServiceArgs) returns (RegisterServiceResponse) {};

  // Generates files inside the enclave data volume on the filesystem for a container
  rpc GenerateFiles(GenerateFilesArgs) returns (GenerateFilesResponse) {};

  // Copies static files that have been registered with the API container into the file namespace of the given service
  rpc LoadStaticFiles(LoadStaticFilesArgs) returns (LoadStaticFilesResponse) {};

  // Starts a previously-registered service by creating a Docker container for it
  rpc StartService(StartServiceArgs) returns (StartServiceResponse) {};

  // Returns relevant information about the service
  rpc GetServiceInfo(GetServiceInfoArgs) returns (GetServiceInfoResponse) {};

  // Instructs the API container to remove the given service
  rpc RemoveService(RemoveServiceArgs) returns (google.protobuf.Empty) {};

  // Instructs the API container to repartition the test network
  rpc Repartition(RepartitionArgs) returns (google.protobuf.Empty) {};

  // Executes the given command inside a running container
  rpc ExecCommand(ExecCommandArgs) returns (ExecCommandResponse) {};

  // Block until the given HTTP endpoint returns available, calling it through a HTTP Get request
  rpc WaitForHttpGetEndpointAvailability(WaitForHttpGetEndpointAvailabilityArgs) returns (google.protobuf.Empty) {};

  // Block until the given HTTP endpoint returns available, calling it through a HTTP Post request
  rpc WaitForHttpPostEndpointAvailability(WaitForHttpPostEndpointAvailabilityArgs) returns (google.protobuf.Empty) {};

  // Executes multiple commands at once
  rpc ExecuteBulkCommands(ExecuteBulkCommandsArgs) returns (google.protobuf.Empty) {};

  // Returns the IDs of the current services in the test network
  rpc GetServices(google.protobuf.Empty) returns (GetServicesResponse) {};

  // Returns the IDs of the Kurtosis Lambdas that have been loaded into the test network.
  rpc GetLambdas(google.protobuf.Empty) returns (GetLambdasResponse) {};
}


// ==============================================================================================
//                                     Load Lambda
// ==============================================================================================
message LoadLambdaArgs {
  string lambda_id = 1;

  string container_image = 2;

  // The serialized params object that will be passed, as-is, to the Lambda for starting
  // The serialization format is dependent on the Lambda
  string serialized_params = 3;
}



// ==============================================================================================
//                                     Execute Lambda
// ==============================================================================================
message ExecuteLambdaArgs {
  string lambda_id = 1;

  // Serialized parameters data for the Lambda function
  // The serialization format is dependent on the Lambda
  string serialized_params = 2;
}

message ExecuteLambdaResponse {
  // Serialized result data from the Lambda function
  // The serialization format is dependent on the Lambda
  string serialized_result = 1;
}



// ==============================================================================================
//                                     Get Lambda Info
// ==============================================================================================
message GetLambdaInfoArgs {
  string lambda_id = 1;
}

message GetLambdaInfoResponse {
  string ip_addr = 1;
}


// ==============================================================================================
//                                       Register Static Files
// ==============================================================================================
message RegisterStaticFilesArgs {
  // A set of user_defined_id identifying static files that the client would like the API container to have available, for use in mounting the files to services
  map<string, bool> static_files_set = 1;
}

message RegisterStaticFilesResponse {
  // Map of user_defined_id -> filepath_relative_to_enclave_volume_root, where user_defined_id corresponds to the
  //  IDs passed in in RegisterStaticFilesArgs
  // The filepaths returned are where the client should copy the data of the file
  // The API container guarantees that an empty file will already have been created at the destination
  map<string, string> static_file_dest_relative_filepaths = 1;
}


// ==============================================================================================
//                                       Register Files Artifacts
// ==============================================================================================
message RegisterFilesArtifactsArgs {
  // A mapping of user_defined_id -> url_of_file_artifact
  map<string, string> files_artifact_urls = 1;
}


// ==============================================================================================
//                                     Register Service
// ==============================================================================================
message RegisterServiceArgs {
  // ID that will be used to identify the service going forward
  string service_id = 1;

  // If emptystring, the default partition ID will be used
  string partition_id = 2;
}

message RegisterServiceResponse {
  // The IP address that the service will receive when it starts
  string ip_addr = 1;
}


// ==============================================================================================
//                                     Generate Files
// ==============================================================================================
message GenerateFilesArgs {
  // The service ID for which the files will be generated
  string service_id = 1;

  // Mapping of meaningful-to-user string ID -> options controlling how the file gets generated
  map<string, FileGenerationOptions> files_to_generate = 2;
}

message FileGenerationOptions {
  enum FileTypeToGenerate {
    FILE = 0;
    // TODO Uncomment and generate directories too
    // DIRECTORY = 1;
  }

  FileTypeToGenerate file_type_to_generate = 1;
}

message GenerateFilesResponse {
  // Mapping of meaningful-to-user string ID (as passed in via the request) to the filepath (RELATIVE to the enclave
  //  data volume root!) where the file was generated
  map<string, string> generated_file_relative_filepaths = 1;
}



// ==============================================================================================
//                                         Load Static Files
// ==============================================================================================
message LoadStaticFilesArgs {
  // The service ID into whose namespace the static files should be copied
  string service_id = 1;

  // The "set" of static files, identified by a user-defined ID key, that should be copied into the service's file namespace
  //  The user-defined ID key should correspond to the keys of the static files declared in the testsuite's getStaticFiles() function
  map<string, bool> static_files = 2;
}

message LoadStaticFilesResponse {
  // A mapping of user_defined_id -> filepath_relative_to_enclave_volume_root where the static files have been copied
  map<string, string> copied_static_file_relative_filepaths = 1;
}

// ==============================================================================================
//                                        Start Service
// ==============================================================================================
message StartServiceArgs {
  // ID of the previously-registered service that should be started
  string service_id = 1;

  string docker_image = 2;

  // "Set" of ports that the running service will listen on
  // This is a string because it's Docker port specification syntax, e.g. "80" (default TCP) or "80/udp"
  map<string, bool> used_ports = 3;

  // Corresponds to a Dockerfile's ENTRYPOINT directive; leave blank to do no overriding
  repeated string entrypoint_args = 4;

  // Corresponds to a Dockerfile's CMD directive; leave blank to do no overriding
  repeated string cmd_args = 5;

  // Docker environment variables that should be set in the service's container
  map<string, string> docker_env_vars = 6;

  // The full path where the API container should mount the enclave data volume on the service container
  string enclave_data_vol_mnt_dirpath = 7;

  // Mapping of files_artifact_id -> filepath_on_container_to_mount_artifact_contents
  map<string, string> files_artifact_mount_dirpaths = 8;
}

message StartServiceResponse {
  // Mapping of used_ports_provided_in_input_args -> ip_and_port_on_host_where_port_is_bound (in ip:port form)
  // Ports will only be in this map if they were successfully bound to a host port; if no ports were bound, then
  // this map will be empty
  map<string, PortBinding> used_ports_host_port_bindings = 1;
}

message PortBinding {
  enum PortProtocol {
    TCP = 0;
    UDP = 1;
  }
    
  // E.g. 0.0.0.0
  string interface_ip = 1;

  // E.g. 2553
  uint32 port_number = 2;

  PortProtocol port_protocol = 3;
}

// ==============================================================================================
//                                       Get Service Info
// ==============================================================================================
message GetServiceInfoArgs {
  //The service ID to get the info from
  string service_id = 1;
}

message GetServiceInfoResponse {
  // The IP address of the service
  string ip_addr = 1;

  // The full path where the enclave data volume is mounted on the service
  string enclave_data_volume_mount_dirpath  = 2;
}

// ==============================================================================================
//                                        Remove Service
// ==============================================================================================
message RemoveServiceArgs {
  string service_id = 1;

  // How long to wait for the service to gracefully stop before hard killing it
  uint64 container_stop_timeout_seconds = 2;
}

// ==============================================================================================
//                                          Repartition
// ==============================================================================================
message RepartitionArgs {
  // Definition of partitionId -> services that should be inside the partition after repartitioning
  map<string, PartitionServices> partition_services = 1;

  // Definition of partitionIdA -> partitionIdB -> information defining the connection between A <-> B
  map<string, PartitionConnections> partition_connections = 2;

  // Information about the default inter-partition connection to set up if one is not defined in the
  //  partition connections map
  PartitionConnectionInfo default_connection = 3;
}

message PartitionServices {
  // "Set" of service IDs in partition
  map<string, bool> service_id_set = 1;
}

message PartitionConnections {
  map<string, PartitionConnectionInfo> connection_info = 1;
}

message PartitionConnectionInfo {
  // Whether network traffic is allowed between the two partitions
  bool is_blocked = 1;
}

// ==============================================================================================
//                                          Exec Command
// ==============================================================================================
message ExecCommandArgs {
  // The service ID of the container that the command should be executed in
  string service_id = 1;

  repeated string command_args = 2;
}

message ExecCommandResponse {
  int32 exit_code = 1;
  bytes log_output = 2;
}

// ==============================================================================================
//                             Wait For HTTP Get Endpoint Availability
// ==============================================================================================
message WaitForHttpGetEndpointAvailabilityArgs {
  //The ID of the service to check.
  string service_id = 1;
  //The port of the service to check. For instance 8080
  uint32 port = 2;
  //The path of the service to check. It mustn't start with the first slash. For instance `service/health`
  string path = 3;
  //The number of milliseconds to wait until executing the first HTTP call
  uint32 initial_delay_milliseconds = 4;
  //Max number of HTTP call attempts that this will execute until giving up and returning an error
  uint32 retries = 5;
  //Number of milliseconds to wait between retries
  uint32 retries_delay_milliseconds = 6;
  //If the endpoint returns this value, the service will be marked as available (e.g. Hello World).
  string body_text = 7;
}

// ==============================================================================================
//                           Wait For HTTP Post Endpoint Availability
// ==============================================================================================
message WaitForHttpPostEndpointAvailabilityArgs {
  //The ID of the service to check.
  string service_id = 1;
  //The port of the service to check. For instance 8080
  uint32 port = 2;
  //The path of the service to check. It mustn't start with the first slash. For instance `service/health`
  string path = 3;
  //The content of the request body.
  string request_body = 4;
  //The number of milliseconds to wait until executing the first HTTP call
  uint32 initial_delay_milliseconds = 5;
  //Max number of HTTP call attempts that this will execute until giving up and returning an error
  uint32 retries = 6;
  //Number of milliseconds to wait between retries
  uint32 retries_delay_milliseconds = 7;
  //If the endpoint returns this value, the service will be marked as available (e.g. Hello World).
  string body_text = 8;
}

// ==============================================================================================
//                                      Execute Bulk Commands
// ==============================================================================================
message ExecuteBulkCommandsArgs {
  // Commands, serialized as JSON
  string serialized_commands = 1;
}

// ==============================================================================================
//                                          Get Services
// ==============================================================================================
message GetServicesResponse {
  // "Set" of current service IDs in the test network
  map<string, bool> service_ids = 1;
}

// ==============================================================================================
//                                          Get Lambdas
// ==============================================================================================
message GetLambdasResponse {
  // "Set" of current Kurtosis Lambda IDs loaded in the test network
  map<string, bool> lambda_ids = 1;
}
