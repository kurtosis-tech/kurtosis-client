// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package kurtosis_core_rpc_api_bindings

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// ApiContainerServiceClient is the client API for ApiContainerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ApiContainerServiceClient interface {
	// Starts a lambda container into the network
	LoadLambda(ctx context.Context, in *LoadLambdaArgs, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Executes a Kurtosis Lambda function on behalf of the user
	ExecuteLambda(ctx context.Context, in *ExecuteLambdaArgs, opts ...grpc.CallOption) (*ExecuteLambdaResponse, error)
	// Gets information about a loaded Lambda module
	GetLambdaInfo(ctx context.Context, in *GetLambdaInfoArgs, opts ...grpc.CallOption) (*GetLambdaInfoResponse, error)
	// Tells the API container that the client has static files it would like the API container to know about
	// The API container will respond with paths inside the enclave directory; the client is then responsible for copying their
	//  files there
	RegisterStaticFiles(ctx context.Context, in *RegisterStaticFilesArgs, opts ...grpc.CallOption) (*RegisterStaticFilesResponse, error)
	// Tells the API container that the client has files artifacts from the web that it would like the API container to know about
	// The API container will download these artifacts locally, so they're available when launching services
	RegisterFilesArtifacts(ctx context.Context, in *RegisterFilesArtifactsArgs, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Registers a service with the API container but doesn't start the container for it
	RegisterService(ctx context.Context, in *RegisterServiceArgs, opts ...grpc.CallOption) (*RegisterServiceResponse, error)
	// Generates files inside the enclave data volume on the filesystem for a container
	GenerateFiles(ctx context.Context, in *GenerateFilesArgs, opts ...grpc.CallOption) (*GenerateFilesResponse, error)
	// Copies static files that have been registered with the API container into the file namespace of the given service
	LoadStaticFiles(ctx context.Context, in *LoadStaticFilesArgs, opts ...grpc.CallOption) (*LoadStaticFilesResponse, error)
	// Starts a previously-registered service by creating a Docker container for it
	StartService(ctx context.Context, in *StartServiceArgs, opts ...grpc.CallOption) (*StartServiceResponse, error)
	// Returns relevant information about the service
	GetServiceInfo(ctx context.Context, in *GetServiceInfoArgs, opts ...grpc.CallOption) (*GetServiceInfoResponse, error)
	// Instructs the API container to remove the given service
	RemoveService(ctx context.Context, in *RemoveServiceArgs, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Instructs the API container to repartition the test network
	Repartition(ctx context.Context, in *RepartitionArgs, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Executes the given command inside a running container
	ExecCommand(ctx context.Context, in *ExecCommandArgs, opts ...grpc.CallOption) (*ExecCommandResponse, error)
	// Block until the given HTTP endpoint returns available, calling it through a HTTP Get request
	WaitForHttpGetEndpointAvailability(ctx context.Context, in *WaitForHttpGetEndpointAvailabilityArgs, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Block until the given HTTP endpoint returns available, calling it through a HTTP Post request
	WaitForHttpPostEndpointAvailability(ctx context.Context, in *WaitForHttpPostEndpointAvailabilityArgs, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Executes multiple commands at once
	ExecuteBulkCommands(ctx context.Context, in *ExecuteBulkCommandsArgs, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Returns the IDs of the current services in the test network
	GetServices(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetServicesResponse, error)
	// Returns the IDs of the Kurtosis Lambdas that have been loaded into the test network.
	GetLambdas(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetLambdasResponse, error)
}

type apiContainerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewApiContainerServiceClient(cc grpc.ClientConnInterface) ApiContainerServiceClient {
	return &apiContainerServiceClient{cc}
}

func (c *apiContainerServiceClient) LoadLambda(ctx context.Context, in *LoadLambdaArgs, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/api_container_api.ApiContainerService/LoadLambda", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiContainerServiceClient) ExecuteLambda(ctx context.Context, in *ExecuteLambdaArgs, opts ...grpc.CallOption) (*ExecuteLambdaResponse, error) {
	out := new(ExecuteLambdaResponse)
	err := c.cc.Invoke(ctx, "/api_container_api.ApiContainerService/ExecuteLambda", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiContainerServiceClient) GetLambdaInfo(ctx context.Context, in *GetLambdaInfoArgs, opts ...grpc.CallOption) (*GetLambdaInfoResponse, error) {
	out := new(GetLambdaInfoResponse)
	err := c.cc.Invoke(ctx, "/api_container_api.ApiContainerService/GetLambdaInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiContainerServiceClient) RegisterStaticFiles(ctx context.Context, in *RegisterStaticFilesArgs, opts ...grpc.CallOption) (*RegisterStaticFilesResponse, error) {
	out := new(RegisterStaticFilesResponse)
	err := c.cc.Invoke(ctx, "/api_container_api.ApiContainerService/RegisterStaticFiles", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiContainerServiceClient) RegisterFilesArtifacts(ctx context.Context, in *RegisterFilesArtifactsArgs, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/api_container_api.ApiContainerService/RegisterFilesArtifacts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiContainerServiceClient) RegisterService(ctx context.Context, in *RegisterServiceArgs, opts ...grpc.CallOption) (*RegisterServiceResponse, error) {
	out := new(RegisterServiceResponse)
	err := c.cc.Invoke(ctx, "/api_container_api.ApiContainerService/RegisterService", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiContainerServiceClient) GenerateFiles(ctx context.Context, in *GenerateFilesArgs, opts ...grpc.CallOption) (*GenerateFilesResponse, error) {
	out := new(GenerateFilesResponse)
	err := c.cc.Invoke(ctx, "/api_container_api.ApiContainerService/GenerateFiles", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiContainerServiceClient) LoadStaticFiles(ctx context.Context, in *LoadStaticFilesArgs, opts ...grpc.CallOption) (*LoadStaticFilesResponse, error) {
	out := new(LoadStaticFilesResponse)
	err := c.cc.Invoke(ctx, "/api_container_api.ApiContainerService/LoadStaticFiles", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiContainerServiceClient) StartService(ctx context.Context, in *StartServiceArgs, opts ...grpc.CallOption) (*StartServiceResponse, error) {
	out := new(StartServiceResponse)
	err := c.cc.Invoke(ctx, "/api_container_api.ApiContainerService/StartService", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiContainerServiceClient) GetServiceInfo(ctx context.Context, in *GetServiceInfoArgs, opts ...grpc.CallOption) (*GetServiceInfoResponse, error) {
	out := new(GetServiceInfoResponse)
	err := c.cc.Invoke(ctx, "/api_container_api.ApiContainerService/GetServiceInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiContainerServiceClient) RemoveService(ctx context.Context, in *RemoveServiceArgs, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/api_container_api.ApiContainerService/RemoveService", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiContainerServiceClient) Repartition(ctx context.Context, in *RepartitionArgs, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/api_container_api.ApiContainerService/Repartition", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiContainerServiceClient) ExecCommand(ctx context.Context, in *ExecCommandArgs, opts ...grpc.CallOption) (*ExecCommandResponse, error) {
	out := new(ExecCommandResponse)
	err := c.cc.Invoke(ctx, "/api_container_api.ApiContainerService/ExecCommand", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiContainerServiceClient) WaitForHttpGetEndpointAvailability(ctx context.Context, in *WaitForHttpGetEndpointAvailabilityArgs, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/api_container_api.ApiContainerService/WaitForHttpGetEndpointAvailability", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiContainerServiceClient) WaitForHttpPostEndpointAvailability(ctx context.Context, in *WaitForHttpPostEndpointAvailabilityArgs, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/api_container_api.ApiContainerService/WaitForHttpPostEndpointAvailability", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiContainerServiceClient) ExecuteBulkCommands(ctx context.Context, in *ExecuteBulkCommandsArgs, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/api_container_api.ApiContainerService/ExecuteBulkCommands", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiContainerServiceClient) GetServices(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetServicesResponse, error) {
	out := new(GetServicesResponse)
	err := c.cc.Invoke(ctx, "/api_container_api.ApiContainerService/GetServices", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiContainerServiceClient) GetLambdas(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetLambdasResponse, error) {
	out := new(GetLambdasResponse)
	err := c.cc.Invoke(ctx, "/api_container_api.ApiContainerService/GetLambdas", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ApiContainerServiceServer is the server API for ApiContainerService service.
// All implementations must embed UnimplementedApiContainerServiceServer
// for forward compatibility
type ApiContainerServiceServer interface {
	// Starts a lambda container into the network
	LoadLambda(context.Context, *LoadLambdaArgs) (*emptypb.Empty, error)
	// Executes a Kurtosis Lambda function on behalf of the user
	ExecuteLambda(context.Context, *ExecuteLambdaArgs) (*ExecuteLambdaResponse, error)
	// Gets information about a loaded Lambda module
	GetLambdaInfo(context.Context, *GetLambdaInfoArgs) (*GetLambdaInfoResponse, error)
	// Tells the API container that the client has static files it would like the API container to know about
	// The API container will respond with paths inside the enclave directory; the client is then responsible for copying their
	//  files there
	RegisterStaticFiles(context.Context, *RegisterStaticFilesArgs) (*RegisterStaticFilesResponse, error)
	// Tells the API container that the client has files artifacts from the web that it would like the API container to know about
	// The API container will download these artifacts locally, so they're available when launching services
	RegisterFilesArtifacts(context.Context, *RegisterFilesArtifactsArgs) (*emptypb.Empty, error)
	// Registers a service with the API container but doesn't start the container for it
	RegisterService(context.Context, *RegisterServiceArgs) (*RegisterServiceResponse, error)
	// Generates files inside the enclave data volume on the filesystem for a container
	GenerateFiles(context.Context, *GenerateFilesArgs) (*GenerateFilesResponse, error)
	// Copies static files that have been registered with the API container into the file namespace of the given service
	LoadStaticFiles(context.Context, *LoadStaticFilesArgs) (*LoadStaticFilesResponse, error)
	// Starts a previously-registered service by creating a Docker container for it
	StartService(context.Context, *StartServiceArgs) (*StartServiceResponse, error)
	// Returns relevant information about the service
	GetServiceInfo(context.Context, *GetServiceInfoArgs) (*GetServiceInfoResponse, error)
	// Instructs the API container to remove the given service
	RemoveService(context.Context, *RemoveServiceArgs) (*emptypb.Empty, error)
	// Instructs the API container to repartition the test network
	Repartition(context.Context, *RepartitionArgs) (*emptypb.Empty, error)
	// Executes the given command inside a running container
	ExecCommand(context.Context, *ExecCommandArgs) (*ExecCommandResponse, error)
	// Block until the given HTTP endpoint returns available, calling it through a HTTP Get request
	WaitForHttpGetEndpointAvailability(context.Context, *WaitForHttpGetEndpointAvailabilityArgs) (*emptypb.Empty, error)
	// Block until the given HTTP endpoint returns available, calling it through a HTTP Post request
	WaitForHttpPostEndpointAvailability(context.Context, *WaitForHttpPostEndpointAvailabilityArgs) (*emptypb.Empty, error)
	// Executes multiple commands at once
	ExecuteBulkCommands(context.Context, *ExecuteBulkCommandsArgs) (*emptypb.Empty, error)
	// Returns the IDs of the current services in the test network
	GetServices(context.Context, *emptypb.Empty) (*GetServicesResponse, error)
	// Returns the IDs of the Kurtosis Lambdas that have been loaded into the test network.
	GetLambdas(context.Context, *emptypb.Empty) (*GetLambdasResponse, error)
	mustEmbedUnimplementedApiContainerServiceServer()
}

// UnimplementedApiContainerServiceServer must be embedded to have forward compatible implementations.
type UnimplementedApiContainerServiceServer struct {
}

func (UnimplementedApiContainerServiceServer) LoadLambda(context.Context, *LoadLambdaArgs) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoadLambda not implemented")
}
func (UnimplementedApiContainerServiceServer) ExecuteLambda(context.Context, *ExecuteLambdaArgs) (*ExecuteLambdaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecuteLambda not implemented")
}
func (UnimplementedApiContainerServiceServer) GetLambdaInfo(context.Context, *GetLambdaInfoArgs) (*GetLambdaInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLambdaInfo not implemented")
}
func (UnimplementedApiContainerServiceServer) RegisterStaticFiles(context.Context, *RegisterStaticFilesArgs) (*RegisterStaticFilesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterStaticFiles not implemented")
}
func (UnimplementedApiContainerServiceServer) RegisterFilesArtifacts(context.Context, *RegisterFilesArtifactsArgs) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterFilesArtifacts not implemented")
}
func (UnimplementedApiContainerServiceServer) RegisterService(context.Context, *RegisterServiceArgs) (*RegisterServiceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterService not implemented")
}
func (UnimplementedApiContainerServiceServer) GenerateFiles(context.Context, *GenerateFilesArgs) (*GenerateFilesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateFiles not implemented")
}
func (UnimplementedApiContainerServiceServer) LoadStaticFiles(context.Context, *LoadStaticFilesArgs) (*LoadStaticFilesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoadStaticFiles not implemented")
}
func (UnimplementedApiContainerServiceServer) StartService(context.Context, *StartServiceArgs) (*StartServiceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartService not implemented")
}
func (UnimplementedApiContainerServiceServer) GetServiceInfo(context.Context, *GetServiceInfoArgs) (*GetServiceInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetServiceInfo not implemented")
}
func (UnimplementedApiContainerServiceServer) RemoveService(context.Context, *RemoveServiceArgs) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveService not implemented")
}
func (UnimplementedApiContainerServiceServer) Repartition(context.Context, *RepartitionArgs) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Repartition not implemented")
}
func (UnimplementedApiContainerServiceServer) ExecCommand(context.Context, *ExecCommandArgs) (*ExecCommandResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecCommand not implemented")
}
func (UnimplementedApiContainerServiceServer) WaitForHttpGetEndpointAvailability(context.Context, *WaitForHttpGetEndpointAvailabilityArgs) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WaitForHttpGetEndpointAvailability not implemented")
}
func (UnimplementedApiContainerServiceServer) WaitForHttpPostEndpointAvailability(context.Context, *WaitForHttpPostEndpointAvailabilityArgs) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WaitForHttpPostEndpointAvailability not implemented")
}
func (UnimplementedApiContainerServiceServer) ExecuteBulkCommands(context.Context, *ExecuteBulkCommandsArgs) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecuteBulkCommands not implemented")
}
func (UnimplementedApiContainerServiceServer) GetServices(context.Context, *emptypb.Empty) (*GetServicesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetServices not implemented")
}
func (UnimplementedApiContainerServiceServer) GetLambdas(context.Context, *emptypb.Empty) (*GetLambdasResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLambdas not implemented")
}
func (UnimplementedApiContainerServiceServer) mustEmbedUnimplementedApiContainerServiceServer() {}

// UnsafeApiContainerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ApiContainerServiceServer will
// result in compilation errors.
type UnsafeApiContainerServiceServer interface {
	mustEmbedUnimplementedApiContainerServiceServer()
}

func RegisterApiContainerServiceServer(s grpc.ServiceRegistrar, srv ApiContainerServiceServer) {
	s.RegisterService(&ApiContainerService_ServiceDesc, srv)
}

func _ApiContainerService_LoadLambda_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadLambdaArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiContainerServiceServer).LoadLambda(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api_container_api.ApiContainerService/LoadLambda",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiContainerServiceServer).LoadLambda(ctx, req.(*LoadLambdaArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiContainerService_ExecuteLambda_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteLambdaArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiContainerServiceServer).ExecuteLambda(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api_container_api.ApiContainerService/ExecuteLambda",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiContainerServiceServer).ExecuteLambda(ctx, req.(*ExecuteLambdaArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiContainerService_GetLambdaInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLambdaInfoArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiContainerServiceServer).GetLambdaInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api_container_api.ApiContainerService/GetLambdaInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiContainerServiceServer).GetLambdaInfo(ctx, req.(*GetLambdaInfoArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiContainerService_RegisterStaticFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterStaticFilesArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiContainerServiceServer).RegisterStaticFiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api_container_api.ApiContainerService/RegisterStaticFiles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiContainerServiceServer).RegisterStaticFiles(ctx, req.(*RegisterStaticFilesArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiContainerService_RegisterFilesArtifacts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterFilesArtifactsArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiContainerServiceServer).RegisterFilesArtifacts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api_container_api.ApiContainerService/RegisterFilesArtifacts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiContainerServiceServer).RegisterFilesArtifacts(ctx, req.(*RegisterFilesArtifactsArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiContainerService_RegisterService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterServiceArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiContainerServiceServer).RegisterService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api_container_api.ApiContainerService/RegisterService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiContainerServiceServer).RegisterService(ctx, req.(*RegisterServiceArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiContainerService_GenerateFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateFilesArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiContainerServiceServer).GenerateFiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api_container_api.ApiContainerService/GenerateFiles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiContainerServiceServer).GenerateFiles(ctx, req.(*GenerateFilesArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiContainerService_LoadStaticFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadStaticFilesArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiContainerServiceServer).LoadStaticFiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api_container_api.ApiContainerService/LoadStaticFiles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiContainerServiceServer).LoadStaticFiles(ctx, req.(*LoadStaticFilesArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiContainerService_StartService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartServiceArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiContainerServiceServer).StartService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api_container_api.ApiContainerService/StartService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiContainerServiceServer).StartService(ctx, req.(*StartServiceArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiContainerService_GetServiceInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetServiceInfoArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiContainerServiceServer).GetServiceInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api_container_api.ApiContainerService/GetServiceInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiContainerServiceServer).GetServiceInfo(ctx, req.(*GetServiceInfoArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiContainerService_RemoveService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveServiceArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiContainerServiceServer).RemoveService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api_container_api.ApiContainerService/RemoveService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiContainerServiceServer).RemoveService(ctx, req.(*RemoveServiceArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiContainerService_Repartition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RepartitionArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiContainerServiceServer).Repartition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api_container_api.ApiContainerService/Repartition",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiContainerServiceServer).Repartition(ctx, req.(*RepartitionArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiContainerService_ExecCommand_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecCommandArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiContainerServiceServer).ExecCommand(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api_container_api.ApiContainerService/ExecCommand",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiContainerServiceServer).ExecCommand(ctx, req.(*ExecCommandArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiContainerService_WaitForHttpGetEndpointAvailability_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WaitForHttpGetEndpointAvailabilityArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiContainerServiceServer).WaitForHttpGetEndpointAvailability(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api_container_api.ApiContainerService/WaitForHttpGetEndpointAvailability",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiContainerServiceServer).WaitForHttpGetEndpointAvailability(ctx, req.(*WaitForHttpGetEndpointAvailabilityArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiContainerService_WaitForHttpPostEndpointAvailability_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WaitForHttpPostEndpointAvailabilityArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiContainerServiceServer).WaitForHttpPostEndpointAvailability(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api_container_api.ApiContainerService/WaitForHttpPostEndpointAvailability",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiContainerServiceServer).WaitForHttpPostEndpointAvailability(ctx, req.(*WaitForHttpPostEndpointAvailabilityArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiContainerService_ExecuteBulkCommands_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteBulkCommandsArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiContainerServiceServer).ExecuteBulkCommands(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api_container_api.ApiContainerService/ExecuteBulkCommands",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiContainerServiceServer).ExecuteBulkCommands(ctx, req.(*ExecuteBulkCommandsArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiContainerService_GetServices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiContainerServiceServer).GetServices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api_container_api.ApiContainerService/GetServices",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiContainerServiceServer).GetServices(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiContainerService_GetLambdas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiContainerServiceServer).GetLambdas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api_container_api.ApiContainerService/GetLambdas",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiContainerServiceServer).GetLambdas(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// ApiContainerService_ServiceDesc is the grpc.ServiceDesc for ApiContainerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ApiContainerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api_container_api.ApiContainerService",
	HandlerType: (*ApiContainerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "LoadLambda",
			Handler:    _ApiContainerService_LoadLambda_Handler,
		},
		{
			MethodName: "ExecuteLambda",
			Handler:    _ApiContainerService_ExecuteLambda_Handler,
		},
		{
			MethodName: "GetLambdaInfo",
			Handler:    _ApiContainerService_GetLambdaInfo_Handler,
		},
		{
			MethodName: "RegisterStaticFiles",
			Handler:    _ApiContainerService_RegisterStaticFiles_Handler,
		},
		{
			MethodName: "RegisterFilesArtifacts",
			Handler:    _ApiContainerService_RegisterFilesArtifacts_Handler,
		},
		{
			MethodName: "RegisterService",
			Handler:    _ApiContainerService_RegisterService_Handler,
		},
		{
			MethodName: "GenerateFiles",
			Handler:    _ApiContainerService_GenerateFiles_Handler,
		},
		{
			MethodName: "LoadStaticFiles",
			Handler:    _ApiContainerService_LoadStaticFiles_Handler,
		},
		{
			MethodName: "StartService",
			Handler:    _ApiContainerService_StartService_Handler,
		},
		{
			MethodName: "GetServiceInfo",
			Handler:    _ApiContainerService_GetServiceInfo_Handler,
		},
		{
			MethodName: "RemoveService",
			Handler:    _ApiContainerService_RemoveService_Handler,
		},
		{
			MethodName: "Repartition",
			Handler:    _ApiContainerService_Repartition_Handler,
		},
		{
			MethodName: "ExecCommand",
			Handler:    _ApiContainerService_ExecCommand_Handler,
		},
		{
			MethodName: "WaitForHttpGetEndpointAvailability",
			Handler:    _ApiContainerService_WaitForHttpGetEndpointAvailability_Handler,
		},
		{
			MethodName: "WaitForHttpPostEndpointAvailability",
			Handler:    _ApiContainerService_WaitForHttpPostEndpointAvailability_Handler,
		},
		{
			MethodName: "ExecuteBulkCommands",
			Handler:    _ApiContainerService_ExecuteBulkCommands_Handler,
		},
		{
			MethodName: "GetServices",
			Handler:    _ApiContainerService_GetServices_Handler,
		},
		{
			MethodName: "GetLambdas",
			Handler:    _ApiContainerService_GetLambdas_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api_container_service.proto",
}
